//! Spectrum implementation.

extern crate crypto;
extern crate rand;

use crate::crypto::msg::Message;
use crypto::buffer::{BufferResult, ReadBuffer, WriteBuffer};
use crypto::{aes, blockmodes, buffer, symmetriccipher};
use rand::{OsRng, Rng};
use rug::{rand::RandState, Assign, Integer};
use std::rc::Rc;

/// PRG uses AES to expand a seed to desired length
#[derive(Clone, PartialEq, Debug)]
pub struct PRG {
    seed_size: usize,
    eval_size: usize,
}

/// seed for a specific PRG
#[derive(Clone, PartialEq, Debug)]
pub struct PRGSeed {
    bytes: Vec<u8>,
}

impl PRG {
    /// generate new PRG: seed_size -> eval_size
    pub fn new(seed_size: usize, eval_size: usize) -> PRG {
        PRG {
            seed_size: seed_size,
            eval_size: eval_size,
        }
    }

    /// generates a new (random) seed for the given PRG
    pub fn new_seed(&self) -> PRGSeed {
        // seed is just random bytes
        let mut key = vec![0; self.seed_size];
        let mut rng = OsRng::new().ok().unwrap();
        rng.fill_bytes(&mut key);

        PRGSeed {
            bytes: key,
        }
    }

    /// evaluates the PRG on the given seed
    pub fn eval(&self, seed: PRGSeed) -> Message {

        // nonce set to zero: PRG eval should be deterministic
        let iv: [u8; 16] = [0; 16];
        let data = vec![0; self.eval_size];

        // code below yanked from https://github.com/DaGenix/rust-crypto/
        // basically does an AES encryption of the all-zero string
        // with the PRG seed as the key
        let mut encryptor = aes::cbc_encryptor(
            aes::KeySize::KeySize128,
            &seed.bytes,
            &iv,
            blockmodes::PkcsPadding,
        );


        // 4096, default buffer size suggested in 
        // https://github.com/DaGenix/rust-crypto/
        let mut buffer = [0; 4096];
        let mut write_buffer = buffer::RefWriteBuffer::new(&mut buffer);

        let mut final_result = Vec::<u8>::new();
        let mut read_buffer = buffer::RefReadBuffer::new(&data);

        // encrypt the data in blocks of size 4096, exit when all blocks are processed
        loop {
            let result = encryptor.encrypt(&mut read_buffer, &mut write_buffer, true);
            final_result.extend(
                write_buffer
                    .take_read_buffer()
                    .take_remaining()
                    .iter()
                    .map(|&i| i),
            );

            match result.unwrap() {
                BufferResult::BufferUnderflow => break,
                BufferResult::BufferOverflow => {}
            }
        }

        assert!(self.eval_size >= final_result.len());


        // cut off extra bits generated by expansion until, this results in 
        // the value of the expanded PRG
        Message {
            data: final_result[0..self.eval_size].to_vec(),
        }
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_prg() {
        // TODO: [for=sss] design a better test. Now only checking that PRG doesn't output all zero string...
        let seed_size: usize = 16;
        let eval_size: usize = 1 << 16;

        let prg = PRG::new(seed_size, eval_size);
        let seed = prg.new_seed();
        let eval_msg = prg.eval(seed);
        let all_zero = vec![0; seed_size];
        assert_ne!(eval_msg.data, all_zero);
    }
}
