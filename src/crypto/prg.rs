//! Spectrum implementation.
extern crate crypto;
extern crate rand;

use crate::crypto::msg::Message;
use crypto::buffer::{BufferResult, ReadBuffer, WriteBuffer};
use crypto::{aes, blockmodes, buffer, symmetriccipher};
use rand::{OsRng, Rng};
use rug::{rand::RandState, Assign, Integer};
use std::rc::Rc;

const BUFFER_SIZE: usize = 4096;

// PRG uses AES to expand a seed to desired length
#[derive(Clone, PartialEq, Debug)]
pub struct PRG {
    seed_size: usize,
    eval_size: usize,
}

// seed for a PRG
#[derive(Clone, PartialEq, Debug)]
pub struct PRGSeed {
    bytes: Vec<u8>,
    prg: std::rc::Rc<PRG>,
}

impl PRG {
    // generate new PRG: seed_size -> eval_size
    pub fn new(seed_size: usize, eval_size: usize) -> PRG {

        // expansion size must be a multiple of BUFFER_SIZE
        assert_eq!(eval_size % BUFFER_SIZE, 0);

        PRG {
            seed_size: seed_size,
            eval_size: eval_size,
        }
    }
}

impl PRGSeed {
    // generate new (random) seed for the given PRG
    pub fn new(prg: std::rc::Rc<PRG>) -> PRGSeed {
        // seed is just random bytes
        let mut key = vec![0; prg.seed_size];
        let mut rng = OsRng::new().ok().unwrap();
        rng.fill_bytes(&mut key);

        PRGSeed {
            bytes: key,
            prg: prg,
        }
    }

    pub fn eval(self) -> Message {
        // nonce set to zero: PRG eval should be deterministic
        let iv: [u8; 16] = [0; 16];
        let data = vec![0; self.prg.eval_size];

        // code below yanked from https://github.com/DaGenix/rust-crypto/
        // basically does an AES encryption of the all-zero string
        // with the PRG seed as the key
        let mut encryptor = aes::cbc_encryptor(
            aes::KeySize::KeySize128,
            &self.bytes,
            &iv,
            blockmodes::PkcsPadding,
        );
        let mut final_result = Vec::<u8>::new();
        let mut read_buffer = buffer::RefReadBuffer::new(&data);

        let mut buffer = [0; BUFFER_SIZE];
        let mut write_buffer = buffer::RefWriteBuffer::new(&mut buffer);
       
        loop {
            let result = encryptor.encrypt(&mut read_buffer, &mut write_buffer, true);
            final_result.extend(write_buffer.take_read_buffer().take_remaining().iter().map(|&i| i));
    
            match result.unwrap() {
                BufferResult::BufferUnderflow => break,
                BufferResult::BufferOverflow => { }
            }
        }
        

        // hack: cut off extra bits generated by expansion until 
        // TODO: find a way to ensure the aes operation expands to eval_size exactly
        Message { data: final_result[0..self.prg.eval_size].to_vec()}
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_prg() {
        // TODO: [for=sss] design a better test. Now only checking that PRG doesn't output all zero string...
        let seed_size: usize = 16;
        let eval_size: usize = (1 << 8) * BUFFER_SIZE;

        let prg = std::rc::Rc::<PRG>::new(PRG::new(seed_size, eval_size));
        let seed = PRGSeed::new(prg);
        let eval_msg = seed.eval();
        let all_zero = vec![0; seed_size];
        assert_ne!(eval_msg.data, all_zero);
    }
}
